# 合同评审AI系统 - 稳定性测试与整改报告

**报告日期**: 2025-12-29  
**系统版本**: v3.0.0  
**测试环境**: Windows 10 Pro

---

## 一、问题背�?
### 1.1 原始问题描述

系统运行时经常出�?Streamlit "Connection error" 弹窗提示�?
```
Connection error
Is Streamlit still running? If you accidentally stopped Streamlit, just restart it in your terminal:
streamlit run yourscript.py
```

同时侧边栏显示：
- �?API服务不可�?- 错误: `HTTPConnectionPool(host='localhost', port=8000): Max retries exceeded with url: /health (Caused by NewConnectionError... Failed to establish a new connection: [WinError 10061] 由于目标计算机积极拒绝，无法连接)`

### 1.2 问题分析

通过代码审查，识别出以下核心问题�?
| 问题 | 位置 | 影响 |
|------|------|------|
| **前端无重试机�?* | `frontend.py` 所�?API 调用 | API 调用失败时直接报�?|
| **健康检查无重连** | `frontend.py:89-95` | 后端重启后前端不会自动恢�?|
| **侧边栏阻塞式检�?* | `frontend.py:586-607` | 每次页面渲染都检查，拖慢性能 |
| **后端 workers=2** | `run_services.py:103` | �?worker 模式可能导致共享状态问�?|
| **无连接池复用** | `frontend.py` 全局 | 每次请求创建新连�?|
| **健康检查过于频�?* | `run_services.py` | 15秒检查一次，2次失败就重启 |

---

## 二、修复方�?
### 2.1 前端 (frontend.py) 修复

#### 2.1.1 添加 HTTP 会话复用和重试机�?
**修改�?*�?```python
import requests

def check_api_health():
    """检查API服务状�?""
    try:
        response = requests.get(f"{API_URL}/health", timeout=5)
        return response.status_code == 200, response.json()
    except Exception as e:
        return False, {"error": str(e)}
```

**修改�?*�?```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

# ========== HTTP 会话配置（带重试机制�?=========
def create_session_with_retry():
    """创建带重试机制的 HTTP 会话"""
    session = requests.Session()
    
    # 配置重试策略
    retry_strategy = Retry(
        total=3,                    # 最大重试次�?        backoff_factor=0.5,         # 重试间隔系数
        status_forcelist=[500, 502, 503, 504],  # 需要重试的状态码
        allowed_methods=["HEAD", "GET", "POST", "PUT", "DELETE"],
    )
    
    adapter = HTTPAdapter(
        max_retries=retry_strategy,
        pool_connections=10,        # 连接池大�?        pool_maxsize=10,            # 最大连接数
    )
    
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    return session

# 全局 HTTP 会话（复用连接）
if 'http_session' not in st.session_state:
    st.session_state.http_session = create_session_with_retry()

# ========== API 健康状态缓�?==========
if 'api_health_cache' not in st.session_state:
    st.session_state.api_health_cache = {
        'status': None,
        'data': None,
        'last_check': 0,
        'cache_duration': 10  # 缓存 10 �?    }

def check_api_health(force_refresh=False):
    """检查API服务状态（带缓存）"""
    cache = st.session_state.api_health_cache
    current_time = time.time()
    
    # 检查缓存是否有�?    if not force_refresh and cache['status'] is not None:
        if current_time - cache['last_check'] < cache['cache_duration']:
            return cache['status'], cache['data']
    
    # 执行健康检�?    try:
        session = get_session()
        response = session.get(f"{API_URL}/health", timeout=5)
        result = (response.status_code == 200, response.json())
        
        # 更新缓存
        cache['status'] = result[0]
        cache['data'] = result[1]
        cache['last_check'] = current_time
        
        return result
    except requests.exceptions.ConnectionError as e:
        cache['status'] = False
        cache['data'] = {"error": f"无法连接到后端服�? {str(e)}"}
        cache['last_check'] = current_time
        return False, cache['data']
    except Exception as e:
        cache['status'] = False
        cache['data'] = {"error": str(e)}
        cache['last_check'] = current_time
        return False, cache['data']
```

#### 2.1.2 所�?API 函数添加重试机制

�?`upload_files` 为例�?
**修改�?*�?```python
def upload_files(files):
    """上传文件到API"""
    try:
        files_data = [
            ("files", (file.name, file, file.type))
            for file in files
        ]
        
        response = requests.post(
            f"{API_URL}/api/upload",
            files=files_data,
            timeout=60
        )
        
        response.raise_for_status()
        return True, response.json()
    
    except Exception as e:
        return False, {"error": str(e)}
```

**修改�?*�?```python
def upload_files(files):
    """上传文件到API（带重试�?""
    max_retries = 3
    
    for attempt in range(max_retries):
        try:
            files_data = [
                ("files", (file.name, file.getvalue(), file.type))
                for file in files
            ]
            
            session = get_session()
            response = session.post(
                f"{API_URL}/api/upload",
                files=files_data,
                timeout=120  # 增加超时时间
            )
            
            response.raise_for_status()
            return True, response.json()
        
        except requests.exceptions.ConnectionError as e:
            if attempt < max_retries - 1:
                time.sleep(1)  # 等待 1 秒后重试
                continue
            return False, {"error": f"无法连接到后端服务，请检查服务是否运�? {str(e)}"}
        except requests.exceptions.Timeout as e:
            if attempt < max_retries - 1:
                time.sleep(1)
                continue
            return False, {"error": f"上传超时，请稍后重试: {str(e)}"}
        except Exception as e:
            return False, {"error": str(e)}
    
    return False, {"error": "上传失败，已达最大重试次�?}
```

#### 2.1.3 侧边栏健康检查优�?
**修改�?*�?```python
# 系统状�?st.markdown("### 🔍 系统状�?)

with st.spinner("检查中..."):
    api_ok, health_data = check_api_health()

if api_ok:
    st.success("�?API服务正常")
    # ...
else:
    st.error("�?API服务不可�?)
    st.caption(f"错误: {health_data.get('error', '未知')}")
```

**修改�?*�?```python
# 系统状态（使用缓存，避免每次刷新都检查）
st.markdown("### 🔍 系统状�?)

# 使用缓存的健康检查结�?api_ok, health_data = check_api_health()

if api_ok:
    st.success("�?API服务正常")
    # ...
else:
    st.error("�?API服务不可�?)
    error_msg = health_data.get('error', '未知') if isinstance(health_data, dict) else str(health_data)
    # 截断过长的错误信�?    if len(error_msg) > 100:
        error_msg = error_msg[:100] + "..."
    st.caption(f"错误: {error_msg}")
    
    # 添加重试按钮
    if st.button("🔄 重新检�?, key="retry_health_check"):
        # 强制刷新健康检�?        check_api_health(force_refresh=True)
        st.rerun()
```

---

### 2.2 服务管理�?(run_services.py) 修复

#### 2.2.1 配置参数优化

**修改�?*�?```python
# 配置
BACKEND_HOST = "127.0.0.1"
BACKEND_PORT = 8000
FRONTEND_PORT = 8501
HEALTH_CHECK_INTERVAL = 15  # 健康检查间�?�?
MAX_RESTART_ATTEMPTS = 10   # 最大重启次�?RESTART_COOLDOWN = 60       # 重启冷却时间(�?
```

**修改�?*�?```python
# 配置
BACKEND_HOST = "127.0.0.1"
BACKEND_PORT = 8000
FRONTEND_PORT = 8501
HEALTH_CHECK_INTERVAL = 30  # 健康检查间�?�? - 增加�?0秒减少检查频�?MAX_RESTART_ATTEMPTS = 5    # 最大重启次�?- 减少�?�?RESTART_COOLDOWN = 120      # 重启冷却时间(�? - 增加�?分钟
STARTUP_WAIT_TIME = 8       # 启动等待时间(�?
```

#### 2.2.2 后端启动配置优化

**修改�?*�?```python
def start_backend(self):
    """启动后端服务"""
    # ...
    self.backend_process = subprocess.Popen(
        [
            sys.executable, "-m", "uvicorn",
            "app.main:app",
            "--host", BACKEND_HOST,
            "--port", str(BACKEND_PORT),
            "--workers", "2",          # 多进�?            "--limit-concurrency", "100",
            "--timeout-keep-alive", "30",
            "--log-level", "warning"
        ],
        # ...
    )
    
    time.sleep(5)
    # ...
```

**修改�?*�?```python
def start_backend(self):
    """启动后端服务"""
    # ...
    # 使用�?worker 模式，避免多进程共享状态问�?    # 增加超时和连接限制参�?    self.backend_process = subprocess.Popen(
        [
            sys.executable, "-m", "uvicorn",
            "app.main:app",
            "--host", BACKEND_HOST,
            "--port", str(BACKEND_PORT),
            "--workers", "1",              # 单进程模式，更稳�?            "--limit-concurrency", "50",   # 限制并发连接�?            "--timeout-keep-alive", "60",  # 保持连接超时
            "--timeout-graceful-shutdown", "10",  # 优雅关闭超时
            "--log-level", "info"          # 保留 info 日志便于调试
        ],
        # ...
    )
    
    time.sleep(STARTUP_WAIT_TIME)
    # ...
```

#### 2.2.3 健康检查优�?
**修改�?*�?```python
def check_backend_health(self):
    """检查后端健康状�?""
    try:
        response = requests.get(
            f"http://{BACKEND_HOST}:{BACKEND_PORT}/health",
            timeout=5
        )
        return response.status_code == 200
    except:
        return False

def health_check_loop(self):
    """健康检查循�?""
    consecutive_failures = {"backend": 0, "frontend": 0}
    
    while self.running:
        time.sleep(HEALTH_CHECK_INTERVAL)
        
        if not self.check_backend_health():
            consecutive_failures["backend"] += 1
            
            if consecutive_failures["backend"] >= 2:  # 2次失败就重启
                self.restart_backend()
                consecutive_failures["backend"] = 0
        else:
            consecutive_failures["backend"] = 0
        # ...
```

**修改�?*�?```python
def check_backend_health(self):
    """检查后端健康状态（带多次重试）"""
    for attempt in range(3):
        try:
            response = requests.get(
                f"http://{BACKEND_HOST}:{BACKEND_PORT}/health",
                timeout=5
            )
            return response.status_code == 200
        except requests.exceptions.ConnectionError:
            if attempt < 2:
                time.sleep(1)
                continue
            return False
        except Exception:
            return False
    return False

def health_check_loop(self):
    """健康检查循环（优化版）"""
    consecutive_failures = {"backend": 0, "frontend": 0}
    check_count = 0
    
    while self.running:
        time.sleep(HEALTH_CHECK_INTERVAL)
        
        if not self.running:
            break
        
        check_count += 1
        
        # 检查后�?        backend_ok = self.check_backend_health()
        if not backend_ok:
            consecutive_failures["backend"] += 1
            logger.warning(f"后端健康检查失�?({consecutive_failures['backend']}/3)")
            
            # 连续失败3次才重启
            if consecutive_failures["backend"] >= 3:
                logger.error("后端连续3次健康检查失败，尝试重启...")
                self.restart_backend()
                consecutive_failures["backend"] = 0
        else:
            if consecutive_failures["backend"] > 0:
                logger.info("后端服务已恢复正�?)
            consecutive_failures["backend"] = 0
        
        # �?0次检查输出一次状态日�?        if check_count % 10 == 0:
            logger.info(f"服务运行正常 (已运�?{check_count * HEALTH_CHECK_INTERVAL // 60} 分钟)")
        # ...
```

---

### 2.3 启动脚本 (start_stable.bat) 优化

**修改�?*�?```batch
@echo off
chcp 65001 >nul
title 合同评审AI系统 - 服务管理�?
echo ============================================================
echo           合同评审AI系统 - 稳定版启动脚�?echo ============================================================

cd /d "%~dp0"

echo 正在启动服务管理器（带自动重启和健康检查）...

python run_services.py

pause
```

**修改�?*�?```batch
@echo off
chcp 65001 >nul
title 合同评审AI系统 - 稳定版服务管理器

echo ============================================================
echo           合同评审AI系统 - 稳定版启动脚�?v2.0
echo ============================================================
echo.

cd /d "%~dp0"

REM 检�?Python 环境
python --version >nul 2>&1
if errorlevel 1 (
    echo [错误] 未找�?Python，请先安�?Python 3.10+
    pause
    exit /b 1
)

REM 检查并终止可能存在的旧进程
echo [1/3] 检查并清理旧进�?..
for /f "tokens=5" %%a in ('netstat -ano ^| findstr ":8000 " ^| findstr "LISTENING"') do (
    echo 终止端口 8000 上的进程 PID=%%a
    taskkill /PID %%a /F >nul 2>&1
)
for /f "tokens=5" %%a in ('netstat -ano ^| findstr ":8501 " ^| findstr "LISTENING"') do (
    echo 终止端口 8501 上的进程 PID=%%a
    taskkill /PID %%a /F >nul 2>&1
)
timeout /t 2 /nobreak >nul

echo [2/3] 检查依�?..
pip show fastapi >nul 2>&1
if errorlevel 1 (
    echo [提示] 正在安装依赖...
    pip install -r requirements.txt
)

echo [3/3] 启动服务管理�?..
echo.
echo ============================================================
echo   服务地址:
echo     后端 API: http://127.0.0.1:8000
echo     API 文档: http://127.0.0.1:8000/docs
echo     前端界面: http://localhost:8501
echo.
echo   �?Ctrl+C 停止所有服�?echo ============================================================
echo.

python run_services.py

pause
```

---

## 三、测试过程与结果

### 3.1 测试脚本

创建�?`test_stability.py` 稳定性测试脚本，包含以下测试项：

1. **后端健康检�?* - 验证 FastAPI 后端服务状�?2. **前端健康检�?* - 验证 Streamlit 前端服务状�?3. **API端点可用�?* - 测试主要 API 端点
4. **连接重试机制** - 验证重试策略有效�?5. **并发请求处理** - 测试并发处理能力
6. **知识库管理功�?* - 验证知识�?API
7. **任务历史管理** - 验证任务历史 API
8. **长时间运行稳定�?* - 30秒持续运行测�?
### 3.2 测试执行

```bash
python test_stability.py --quick
```

### 3.3 测试结果

```
[2025-12-29 17:33:49] [INFO] 运行快速测试模式（跳过长时间测试）
[2025-12-29 17:33:49] [INFO] ============================================================
[2025-12-29 17:33:49] [INFO] 合同评审AI系统 - 稳定性测�?[2025-12-29 17:33:49] [INFO] ============================================================
[2025-12-29 17:33:49] [INFO] ----------------------------------------
[2025-12-29 17:33:49] [INFO] 测试1: 后端健康检�?[2025-12-29 17:33:51] [INFO]   �?FastAPI: ok
[2025-12-29 17:33:51] [INFO]   �?CodeBuddy: error
[2025-12-29 17:33:51] [INFO]   �?MarkItDown: ok
[2025-12-29 17:33:52] [INFO] ----------------------------------------
[2025-12-29 17:33:52] [INFO] 测试2: 前端健康检�?[2025-12-29 17:33:52] [INFO]   �?Streamlit 前端正常
[2025-12-29 17:33:53] [INFO] ----------------------------------------
[2025-12-29 17:33:53] [INFO] 测试3: API端点可用�?[2025-12-29 17:33:53] [INFO]   �?根路�? 200
[2025-12-29 17:33:55] [INFO]   �?健康检�? 200
[2025-12-29 17:33:55] [INFO]   �?知识库列�? 200
[2025-12-29 17:33:55] [INFO]   �?历史统计: 200
[2025-12-29 17:33:56] [INFO] ----------------------------------------
[2025-12-29 17:33:56] [INFO] 测试4: 连接重试机制
[2025-12-29 17:34:09] [INFO]   连接成功�? 5/5 (100%)
[2025-12-29 17:34:10] [INFO] ----------------------------------------
[2025-12-29 17:34:10] [INFO] 测试5: 并发请求处理
[2025-12-29 17:34:12] [INFO]   并发成功�? 10/10 (100%)
[2025-12-29 17:34:13] [INFO] ----------------------------------------
[2025-12-29 17:34:13] [INFO] 测试6: 知识库管理功�?[2025-12-29 17:34:13] [INFO]   �?知识库文件数: 8
[2025-12-29 17:34:14] [INFO] ----------------------------------------
[2025-12-29 17:34:14] [INFO] 测试7: 任务历史管理
[2025-12-29 17:34:14] [INFO]   �?总任务数: 3
[2025-12-29 17:34:14] [INFO]   �?已完�? 2
[2025-12-29 17:34:15] [INFO] ============================================================
[2025-12-29 17:34:15] [INFO] 测试结果汇�?[2025-12-29 17:34:15] [INFO] ============================================================
[2025-12-29 17:34:15] [INFO]   �?后端健康检�? PASS
[2025-12-29 17:34:15] [INFO]   �?前端健康检�? PASS
[2025-12-29 17:34:15] [INFO]   �?API端点可用�? PASS
[2025-12-29 17:34:15] [INFO]   �?连接重试机制: PASS
[2025-12-29 17:34:15] [INFO]   �?并发请求处理: PASS
[2025-12-29 17:34:15] [INFO]   �?知识库管理功�? PASS
[2025-12-29 17:34:15] [INFO]   �?任务历史管理: PASS
[2025-12-29 17:34:15] [INFO] ----------------------------------------
[2025-12-29 17:34:15] [INFO] 通过: 7, 失败: 0, 部分: 0
[2025-12-29 17:34:15] [INFO] 总体评估: 稳定
```

### 3.4 测试结果汇�?
| 测试�?| 状�?| 详情 |
|--------|------|------|
| 后端健康检�?| �?PASS | FastAPI: ok, MarkItDown: ok |
| 前端健康检�?| �?PASS | Streamlit 服务正常 |
| API端点可用�?| �?PASS | 4/4 端点正常 |
| 连接重试机制 | �?PASS | 成功�? 100% |
| 并发请求处理 | �?PASS | 成功�? 100% (10/10) |
| 知识库管理功�?| �?PASS | �?8 个知识库文件 |
| 任务历史管理 | �?PASS | 总任务数: 3, 已完�? 2 |

**总体评估: 稳定**

---

## 四、修改文件清�?
| 文件 | 修改类型 | 说明 |
|------|----------|------|
| `app/frontend.py` | 修改 | 添加 HTTP 会话复用、重试机制、健康检查缓�?|
| `run_services.py` | 修改 | 优化配置参数、改用单 worker 模式、优化健康检查逻辑 |
| `start_stable.bat` | 修改 | 添加进程清理、依赖检查、改进启动流�?|
| `test_stability.py` | 新增 | 稳定性测试脚�?|
| `稳定性测试报�?md` | 新增 | 本报告文�?|

---

## 五、使用说�?
### 5.1 推荐启动方式

```batch
cd /path/to/contract-review-ai
start_stable.bat
```

### 5.2 运行稳定性测�?
```batch
# 完整测试（包�?0秒持续运行测试）
python test_stability.py

# 快速测�?python test_stability.py --quick
```

### 5.3 服务管理命令

```batch
# 检查服务状�?python run_services.py --check

# 停止所有服�?python run_services.py --stop
```

---

## 六、注意事�?
1. **CodeBuddy 状态显�?error 是正常的**
   - 系统使用 CLI 模式调用 CodeBuddy，不依赖 HTTP API
   - CodeBuddy HTTP 服务未启动不影响系统功能

2. **如果仍出现连接问�?*
   - 运行 `python run_services.py --stop` 清理进程
   - 等待 5 秒后重新运行 `start_stable.bat`

3. **日志文件位置**
   - 服务管理器日�? `logs/service_manager.log`
   - 应用日志: `logs/app.log`

4. **性能建议**
   - 避免同时打开多个浏览器标签页访问系统
   - 大文件上传时请耐心等待，超时时间已增加�?120 �?
---

## 七、后续改进建�?
1. **增加数据库连接池** - 使用 SQLAlchemy 连接池提高数据库访问稳定�?2. **添加请求限流** - 防止恶意或过多请求导致服务过�?3. **实现优雅重启** - 在重启前完成正在处理的请�?4. **增加监控告警** - 集成 Prometheus/Grafana 进行实时监控
5. **容器化部�?* - 使用 Docker 容器化提高部署一致�?
---

**报告完成**

*生成时间: 2025-12-29 17:34*
