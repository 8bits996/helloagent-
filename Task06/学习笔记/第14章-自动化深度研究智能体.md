# 第14章 学习笔记 - 自动化深度研究智能体

**学习日期**: 2025-12-26  
**章节**: 第十四章 - DeepResearch Agent 复现与解析  
**状态**: 📖 学习中

---

## 🎯 本章学习目标

### 核心目标
1. ✅ 理解自动化研究的工作流程和设计思路
2. ✅ 掌握 TODO 驱动的研究范式
3. ✅ 学习多 Agent 顺序协作模式
4. ✅ 实现知识密集型应用的架构设计

### 能力提升
- 复杂信息检索与整合能力
- 多轮推理与反思机制
- 结构化报告生成能力
- RAG 系统在研究场景的应用

---

## 📚 章节内容概览

### 14.1 项目概述与架构设计

#### 为什么需要深度研究助手？

**传统研究方式的三大痛点**:

1. **信息过载**
   - 搜索引擎返回成千上万的结果
   - 需要逐个筛选、阅读、判断
   - 大量时间浪费在信息筛选上

2. **缺少结构**
   - 信息碎片化，难以系统组织
   - 缺乏整体视角和逻辑框架
   - 难以形成完整的知识体系

3. **重复劳动**
   - 每次都要重复"搜索→阅读→总结→整理"
   - 研究过程无法复用
   - 缺少可追溯的研究记录

**深度研究助手的核心价值**:

```
传统研究流程 (1-2小时):
用户提问 → 手动搜索 → 逐个阅读 → 手工整理 → 形成报告

AI研究助手 (5-10分钟):
用户提问 → AI规划 → 自动搜索 → AI总结 → 生成报告
```

**四大核心价值**:
- ⏱️ **节省时间**: 1-2小时 → 5-10分钟
- 📊 **提高质量**: 系统化流程，避免遗漏
- 🔍 **可追溯**: 记录所有来源和引用
- 🔧 **可扩展**: 轻松添加新搜索引擎和工具

#### 技术架构设计

**四层架构**:

```
┌─────────────────────────────────────────┐
│         前端层 (Vue3 + TypeScript)       │
│   全屏模态对话框 + Markdown 可视化       │
└─────────────────┬───────────────────────┘
                  │ SSE (Server-Sent Events)
┌─────────────────┴───────────────────────┐
│         后端层 (FastAPI)                 │
│   API路由 + 状态管理 + 流式响应          │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────┴───────────────────────┐
│      智能体层 (HelloAgents)              │
│  ┌──────────┐ ┌──────────┐ ┌─────────┐ │
│  │ Planner  │→│Summarizer│→│Reporter │ │
│  │  Agent   │ │  Agent   │ │ Agent   │ │
│  └────┬─────┘ └────┬─────┘ └────┬────┘ │
│       │            │              │      │
│  ┌────┴────────────┴──────────────┴───┐ │
│  │       SearchTool + NoteTool         │ │
│  └─────────────────┬───────────────────┘ │
└────────────────────┴─────────────────────┘
                     │
┌────────────────────┴─────────────────────┐
│         外部服务层                        │
│  Tavily/DuckDuckGo + LLM Provider        │
└──────────────────────────────────────────┘
```

**数据流转过程**:

```
1. 用户输入研究主题 (前端)
   ↓
2. 建立 SSE 连接 (前端→后端)
   ↓
3. 创建研究状态 (后端)
   ↓
4. 规划阶段: Planner Agent 分解为 3-5 个子任务
   ↓
5. 执行阶段: 对每个子任务
   - SearchTool 搜索信息
   - Summarizer Agent 总结
   - NoteTool 记录结果
   ↓
6. 报告阶段: Reporter Agent 整合所有总结
   ↓
7. 流式返回结果 (后端→前端)
   ↓
8. 实时更新展示 (前端)
```

#### 项目结构分析

```
helloagents-deepresearch/
├── backend/                          # Python 后端
│   ├── src/
│   │   ├── agent.py                  # 核心 Agent 定义
│   │   ├── main.py                   # FastAPI 入口
│   │   ├── models.py                 # 数据模型
│   │   ├── prompts.py                # Prompt 模板
│   │   ├── config.py                 # 配置管理
│   │   ├── utils.py                  # 工具函数
│   │   └── services/                 # 服务层
│   │       ├── planner.py            # 规划服务
│   │       ├── search.py             # 搜索服务
│   │       ├── summarizer.py         # 总结服务
│   │       ├── reporter.py           # 报告服务
│   │       ├── notes.py              # 笔记管理
│   │       ├── tool_events.py        # 工具事件监听
│   │       └── text_processing.py    # 文本处理
│   ├── .env.example                  # 环境变量示例
│   └── pyproject.toml                # 项目依赖
│
└── frontend/                         # Vue3 前端
    ├── src/
    │   ├── App.vue                   # 主应用组件
    │   ├── components/               # UI 组件
    │   │   ├── ResearchModal.vue     # 研究对话框
    │   │   ├── ProgressDisplay.vue   # 进度展示
    │   │   └── MarkdownViewer.vue    # Markdown 渲染
    │   └── composables/              # 组合式函数
    │       └── useResearch.ts        # 研究逻辑
    └── package.json
```

---

### 14.2 TODO 驱动的研究范式

#### 什么是 TODO 驱动？

**核心思想**: 将"研究"这个复杂、开放的任务，转化为"规划→执行→整合"的结构化流程。

**对比分析**:

| 维度 | 传统方式 | TODO 驱动方式 |
|------|---------|--------------|
| **规划** | 用户自己规划 | AI 智能分解 |
| **执行** | 用户手动搜索 | AI 自动执行 |
| **整合** | 用户整理笔记 | AI 生成报告 |
| **时间** | 1-2 小时 | 5-10 分钟 |
| **质量** | 依赖用户能力 | 系统化保证 |
| **可追溯** | 难以追溯 | 完整记录 |

**三个核心要素**:

1. **智能规划器 (TODO Planner)**
   - 接收研究主题
   - 分解为 3-5 个子任务
   - 每个任务包含: title, intent, query

2. **任务执行器 (Task Executor)**
   - 逐个执行子任务
   - 搜索 → 总结 → 记录
   - 实时推送进度

3. **报告生成器 (Report Writer)**
   - 整合所有子任务结果
   - 生成结构化报告
   - 添加引用和来源

#### 三阶段研究流程

**阶段 1: 规划 (Planning)**

```python
输入:
- 研究主题: "量子计算的最新进展"
- 当前日期: "2025-12-26"

输出 (JSON格式):
{
  "todos": [
    {
      "title": "量子计算基础概念",
      "intent": "了解量子计算的基本原理和核心概念",
      "query": "quantum computing fundamentals 2025"
    },
    {
      "title": "最新技术突破",
      "intent": "调研 2025 年的重大技术进展",
      "query": "quantum computing breakthroughs 2025"
    },
    {
      "title": "商业应用前景",
      "intent": "分析量子计算的实际应用场景",
      "query": "quantum computing applications industry 2025"
    }
  ]
}
```

**设计要点**:
- ✅ 包含当前日期以获取最新信息
- ✅ 明确要求 JSON 格式输出
- ✅ 提供示例帮助理解
- ✅ 强调子任务数量 (3-5个)
- ✅ 确保子任务之间有逻辑关系

**阶段 2: 执行 (Execution)**

```python
对每个子任务循环执行:

Step 1: 搜索
search_result = SearchTool.run({
    "input": task.query,
    "backend": "tavily",  # 或 duckduckgo
    "max_results": 5
})

Step 2: 总结
summary = SummarizerAgent.run({
    "task_title": task.title,
    "task_intent": task.intent,
    "search_results": search_result
})

Step 3: 记录
NoteTool.save({
    "task_id": task.id,
    "content": summary,
    "sources": search_result.sources
})

Step 4: 推送进度
stream_progress({
    "type": "task_complete",
    "task": task.title,
    "progress": f"{current}/{total}"
})
```

**执行特点**:
- 🔄 **顺序执行**: 一个任务完成后再执行下一个
- 📊 **实时反馈**: 每完成一个任务就推送进度
- 💾 **持久化**: 每个任务的结果都保存到文件
- 🔍 **可追溯**: 记录所有搜索来源

**阶段 3: 报告 (Reporting)**

```python
输入:
- 所有子任务的总结
- 原始研究主题
- 所有引用来源

输出 (Markdown格式):
# 量子计算的最新进展

## 概述
本研究报告深入分析了量子计算在 2025 年的最新进展...

## 详细分析

### 1. 量子计算基础概念
[子任务1的详细内容]

### 2. 最新技术突破
[子任务2的详细内容]

### 3. 商业应用前景
[子任务3的详细内容]

## 总结
综合以上分析，量子计算正在从实验室走向商业化...

## 参考文献
1. [来源1]
2. [来源2]
...
```

**报告结构**:
1. **标题**: 研究主题
2. **概述**: 2-3段总体介绍
3. **详细分析**: 每个子任务的详细内容
4. **总结**: 1-2段总结性描述
5. **参考文献**: 所有引用来源

---

### 14.3 智能体系统设计

#### Agent 职责划分

**三个专门 Agent 的设计**:

| Agent | 职责 | 输入 | 输出 | 核心能力 |
|-------|------|------|------|----------|
| **TODO Planner** | 研究规划 | 主题+日期 | 子任务列表(JSON) | 问题分解 |
| **Task Summarizer** | 内容总结 | 任务+搜索结果 | 总结(Markdown) | 信息提取 |
| **Report Writer** | 报告撰写 | 所有总结 | 报告(Markdown) | 知识整合 |

**Agent 1: 研究规划专家 (TODO Planner)**

```python
角色定位:
- 擅长将开放性问题分解为具体的研究任务
- 理解如何构建逻辑清晰的研究框架
- 知道如何制定有效的搜索查询

Prompt 设计要点:
1. 明确角色和目标
2. 提供当前日期（获取最新信息）
3. 强调输出格式（JSON）
4. 给出具体示例
5. 设定约束条件（3-5个任务）

输出格式:
{
  "todos": [
    {
      "title": "子任务标题",
      "intent": "研究意图说明",
      "query": "英文搜索查询"
    }
  ]
}

关键约束:
- 子任务数量: 3-5 个
- 查询语言: 英文（搜索效果更好）
- 逻辑关系: 从基础到深入，从宏观到微观
- 覆盖面: 全面但不重复
```

**Agent 2: 任务总结专家 (Task Summarizer)**

```python
角色定位:
- 擅长从大量信息中提取核心观点
- 能够识别和保留关键数据
- 善于为每个观点添加来源引用

核心任务:
1. 提取核心观点（3-5个要点）
2. 保留关键数据（数字、日期、名称）
3. 添加来源引用（[1], [2] 格式）
4. 使用 Markdown 格式化

输出格式:
## 任务标题

### 核心发现
- 观点1: 详细描述 [1]
- 观点2: 详细描述 [2]
- 观点3: 详细描述 [3]

### 关键数据
- 数据1: 具体数值 [1]
- 数据2: 具体数值 [2]

### 来源
[1] URL1
[2] URL2
[3] URL3

质量标准:
- 信息准确: 忠实原文，不编造
- 来源明确: 每个观点都有引用
- 结构清晰: 使用 Markdown 分层
- 重点突出: 提取最重要的信息
```

**Agent 3: 报告撰写专家 (Report Writer)**

```python
角色定位:
- 擅长整合多个来源的信息
- 能够撰写结构化、专业的研究报告
- 善于用通俗语言解释复杂概念

报告结构 (5个部分):
1. 标题
   - 直接使用研究主题
   
2. 概述 (2-3段)
   - 背景介绍
   - 研究范围
   - 主要发现预告

3. 详细分析
   - 每个子任务一个章节
   - 保留原始总结的所有引用
   - 使用二级标题组织

4. 总结 (1-2段)
   - 综合所有发现
   - 提出见解和展望

5. 参考文献
   - 列出所有引用来源
   - 按编号排序

写作要求:
- 语言专业但易懂
- 逻辑清晰连贯
- 保留所有引用
- 格式统一规范
```

#### ToolAwareSimpleAgent 设计

**为什么需要 ToolAwareSimpleAgent？**

普通的 `SimpleAgent` 无法监听工具调用过程，我们需要扩展它来支持：
- 📊 实时推送工具调用进度
- 🔍 记录工具调用历史
- 🐛 调试和问题诊断

**实现原理**:

```python
from helloagents import SimpleAgent

class ToolAwareSimpleAgent(SimpleAgent):
    """
    扩展 SimpleAgent，增加工具调用监听能力
    """
    
    def __init__(
        self, 
        name: str,
        llm,
        tool_registry,
        tool_call_listener=None  # 新增: 工具调用监听器
    ):
        super().__init__(name, llm, tool_registry)
        self._tool_call_listener = tool_call_listener
    
    def _execute_tool_call(self, tool_name: str, parameters: dict):
        """
        重写工具调用方法，添加监听逻辑
        """
        # 1. 执行原始工具调用
        result = super()._execute_tool_call(tool_name, parameters)
        
        # 2. 如果有监听器，触发回调
        if self._tool_call_listener:
            self._tool_call_listener({
                "agent_name": self.name,
                "tool_name": tool_name,
                "parameters": parameters,
                "result": result,
                "timestamp": datetime.now()
            })
        
        # 3. 返回结果
        return result
```

**使用示例**:

```python
# 定义监听器
def on_tool_call(event):
    print(f"[{event['agent_name']}] 调用工具: {event['tool_name']}")
    print(f"  参数: {event['parameters']}")
    print(f"  结果长度: {len(event['result'])}")

# 创建 Agent
agent = ToolAwareSimpleAgent(
    name="研究助手",
    llm=llm,
    tool_registry=registry,
    tool_call_listener=on_tool_call  # 传入监听器
)

# 运行时会自动触发监听
agent.run("研究量子计算")
# 输出:
# [研究助手] 调用工具: search
#   参数: {'query': 'quantum computing 2025'}
#   结果长度: 5432
```

**应用场景**:
1. **实时进度推送**: 将工具调用进度推送到前端
2. **日志记录**: 记录所有工具调用用于审计
3. **性能监控**: 统计每个工具的调用时间
4. **调试诊断**: 查看工具调用的详细信息

#### Agent 协作模式

**顺序协作模式特点**:

```
特点对比:

并行协作 (第13章旅行助手):
┌─────────┐  ┌─────────┐  ┌─────────┐
│ Agent A │  │ Agent B │  │ Agent C │
└────┬────┘  └────┬────┘  └────┬────┘
     └──────┬─────┴──────┬──────┘
            │  同时执行   │
            ↓            ↓

顺序协作 (第14章研究助手):
┌─────────┐
│ Planner │ → 规划任务
└────┬────┘
     ↓
┌─────────┐
│Summarizer│ → 执行任务 (循环)
└────┬────┘
     ↓
┌─────────┐
│ Reporter │ → 生成报告
└─────────┘
```

**顺序协作的优势**:
1. ✅ **逻辑清晰**: 先规划、再执行、后整合
2. ✅ **易于调试**: 每个阶段独立，问题容易定位
3. ✅ **节省成本**: 不同阶段可以使用不同的模型
4. ✅ **结果可控**: 每个阶段的输出都可以验证

**核心协调器: DeepResearchAgent**

```python
class DeepResearchAgent:
    """
    深度研究智能体 - 协调三个专门 Agent
    """
    
    def __init__(self):
        self.planner = ToolAwareSimpleAgent(...)      # 规划 Agent
        self.summarizer = ToolAwareSimpleAgent(...)   # 总结 Agent
        self.reporter = ToolAwareSimpleAgent(...)     # 报告 Agent
        
        self.search_tool = SearchTool(...)
        self.note_tool = NoteTool(...)
    
    async def research(self, topic: str):
        """
        执行完整的研究流程
        """
        # 阶段 1: 规划
        todos = await self._plan(topic)
        
        # 阶段 2: 执行
        for i, todo in enumerate(todos):
            # 2.1 搜索
            search_results = await self._search(todo.query)
            
            # 2.2 总结
            summary = await self._summarize(todo, search_results)
            
            # 2.3 记录
            await self._save_note(i, summary)
            
            # 2.4 推送进度
            await self._push_progress(i, len(todos))
        
        # 阶段 3: 报告
        report = await self._generate_report(todos)
        
        return report
    
    async def _plan(self, topic: str):
        """阶段1: 规划"""
        response = await self.planner.run(
            f"研究主题: {topic}\n当前日期: {date.today()}"
        )
        return parse_json(response)
    
    async def _summarize(self, todo, search_results):
        """阶段2: 总结"""
        prompt = f"""
        任务: {todo.title}
        意图: {todo.intent}
        搜索结果: {search_results}
        
        请总结核心发现。
        """
        return await self.summarizer.run(prompt)
    
    async def _generate_report(self, todos):
        """阶段3: 报告"""
        # 读取所有笔记
        notes = [self.note_tool.read(i) for i in range(len(todos))]
        
        # 生成报告
        prompt = f"""
        研究主题: {self.topic}
        子任务总结: {notes}
        
        请生成最终研究报告。
        """
        return await self.reporter.run(prompt)
```

---

### 14.4 工具系统集成

#### SearchTool 扩展

**支持的搜索引擎对比**:

| 搜索引擎 | 特点 | 优势 | 劣势 | 成本 |
|---------|------|------|------|------|
| **Tavily** | AI优化 | 结果质量高、去重好 | 需要API密钥 | 付费 |
| **DuckDuckGo** | 隐私保护 | 免费、无需密钥 | 结果一般 | 免费 |
| **Perplexity** | AI生成 | 直接给答案 | 需要API密钥 | 付费 |
| **SearXNG** | 自托管 | 隐私、可控 | 需要自己搭建 | 免费 |
| **Advanced** | 组合模式 | 结果全面 | 调用多个API | 混合 |

**统一调用接口**:

```python
from helloagents.tools import SearchTool

# 初始化搜索工具
search_tool = SearchTool(
    name="web_search",
    description="搜索互联网信息",
    backend="tavily",  # 可选: tavily, duckduckgo, perplexity, searxng
    api_key="your-api-key"  # Tavily/Perplexity 需要
)

# 使用搜索
result = search_tool.run({
    "input": "量子计算最新进展 2025",
    "max_results": 5,
    "mode": "structured"  # 结构化结果
})

# 结果格式
{
    "results": [
        {
            "title": "文章标题",
            "url": "https://...",
            "content": "内容摘要...",
            "score": 0.95
        },
        ...
    ],
    "query": "原始查询",
    "backend": "tavily"
}
```

**配置方法**:

```bash
# .env 文件配置
SEARCH_API=tavily                    # 选择搜索引擎
TAVILY_API_KEY=tvly-xxxxx           # Tavily API 密钥
PERPLEXITY_API_KEY=pplx-xxxxx       # Perplexity API 密钥
SEARXNG_URL=http://localhost:8888   # SearXNG 服务地址
```

#### NoteTool 使用

**作用**: 持久化研究进度和结果

```python
from helloagents.tools import NoteTool

# 初始化笔记工具
note_tool = NoteTool(
    name="research_notes",
    description="保存和读取研究笔记",
    workspace="./workspace/research_001"
)

# 保存笔记
note_tool.run({
    "action": "save",
    "filename": "task_1.md",
    "content": """
## 量子计算基础概念

### 核心发现
- 观点1...
- 观点2...
    """
})

# 读取笔记
note = note_tool.run({
    "action": "read",
    "filename": "task_1.md"
})

# 列出所有笔记
notes = note_tool.run({
    "action": "list"
})
```

**文件组织结构**:

```
workspace/
└── research_001/              # 单次研究的工作空间
    ├── notes/                 # 子任务笔记
    │   ├── task_1.md         # 任务1总结
    │   ├── task_2.md         # 任务2总结
    │   └── task_3.md         # 任务3总结
    ├── reports/               # 研究报告
    │   └── final_report.md   # 最终报告
    └── meta.json             # 元数据
```

**meta.json 示例**:

```json
{
  "research_id": "research_001",
  "topic": "量子计算的最新进展",
  "created_at": "2025-12-26T10:30:00",
  "status": "completed",
  "tasks": [
    {
      "id": 1,
      "title": "量子计算基础概念",
      "status": "completed",
      "note_file": "task_1.md"
    },
    {
      "id": 2,
      "title": "最新技术突破",
      "status": "completed",
      "note_file": "task_2.md"
    }
  ]
}
```

**应用场景**:
1. ✅ **进度恢复**: 如果研究中断，可以从笔记恢复
2. ✅ **审计追溯**: 查看研究的完整过程
3. ✅ **结果复用**: 保存的笔记可以用于后续研究
4. ✅ **调试分析**: 检查每个阶段的输出质量

#### ToolRegistry 工具管理

**作用**: 统一管理所有工具的注册和调用

```python
from helloagents import ToolRegistry

# 创建工具注册表
registry = ToolRegistry()

# 注册搜索工具
registry.register_tool(search_tool)

# 注册笔记工具
registry.register_tool(note_tool)

# 创建 Agent (自动使用注册的工具)
agent = ToolAwareSimpleAgent(
    name="研究助手",
    llm=llm,
    tool_registry=registry
)

# Agent 会自动发现和使用已注册的工具
agent.run("搜索量子计算信息")
# → 自动调用 search_tool

agent.run("保存研究笔记")
# → 自动调用 note_tool
```

**工具发现机制**:

```python
# Agent 如何知道该用哪个工具？
# 1. 从 registry 获取所有工具的描述
tools_desc = registry.get_all_descriptions()

# 2. 将工具描述添加到 Prompt
prompt = f"""
你有以下工具可用:
- web_search: 搜索互联网信息
- research_notes: 保存和读取研究笔记

用户请求: {user_input}

请选择合适的工具并调用。
"""

# 3. LLM 返回工具调用
response = llm.call(prompt)
# → {"tool": "web_search", "parameters": {...}}

# 4. Registry 执行工具调用
result = registry.execute(response["tool"], response["parameters"])
```

**优势**:
- 🔧 **解耦**: Agent 不需要知道工具的具体实现
- 🔌 **插拔**: 可以随时添加/移除工具
- 🔄 **复用**: 同一组工具可以被多个 Agent 使用
- 🐛 **调试**: 统一的调用入口便于监控和调试

---

### 14.5 服务层实现

服务层是连接 Agent 和工具的桥梁，负责业务逻辑和流程控制。

#### 服务层架构

```
services/
├── planner.py           # 规划服务
├── search.py            # 搜索服务
├── summarizer.py        # 总结服务
├── reporter.py          # 报告服务
├── notes.py             # 笔记服务
├── tool_events.py       # 工具事件监听
└── text_processing.py   # 文本处理
```

#### PlanningService (规划服务)

**职责**: 调用 Planner Agent 生成研究计划

```python
class PlanningService:
    """
    研究规划服务
    """
    
    def __init__(self, planner_agent):
        self.planner = planner_agent
    
    async def create_plan(self, topic: str) -> List[Task]:
        """
        创建研究计划
        
        Args:
            topic: 研究主题
            
        Returns:
            任务列表
        """
        # 1. 构建规划 Prompt
        prompt = self._build_prompt(topic)
        
        # 2. 调用 Planner Agent
        response = await self.planner.run(prompt)
        
        # 3. 解析 JSON 响应
        tasks = self._parse_response(response)
        
        # 4. 验证任务格式
        validated_tasks = self._validate_tasks(tasks)
        
        return validated_tasks
    
    def _build_prompt(self, topic: str) -> str:
        """构建规划 Prompt"""
        return f"""
研究主题: {topic}
当前日期: {date.today()}

请将此主题分解为 3-5 个子任务，使用 JSON 格式输出。

示例输出:
{{
  "todos": [
    {{
      "title": "子任务标题",
      "intent": "研究意图",
      "query": "搜索查询"
    }}
  ]
}}
        """
    
    def _parse_response(self, response: str) -> List[dict]:
        """解析 JSON 响应"""
        try:
            # 提取 JSON 部分
            json_str = extract_json(response)
            
            # 解析 JSON
            data = json.loads(json_str)
            
            return data.get("todos", [])
        except Exception as e:
            raise ValueError(f"无法解析规划响应: {e}")
    
    def _validate_tasks(self, tasks: List[dict]) -> List[Task]:
        """验证任务格式"""
        validated = []
        
        for task in tasks:
            # 检查必需字段
            if not all(k in task for k in ["title", "intent", "query"]):
                raise ValueError(f"任务缺少必需字段: {task}")
            
            # 创建 Task 对象
            validated.append(Task(
                title=task["title"],
                intent=task["intent"],
                query=task["query"]
            ))
        
        # 检查任务数量
        if not (3 <= len(validated) <= 5):
            raise ValueError(f"任务数量应为 3-5 个，实际: {len(validated)}")
        
        return validated
```

#### SearchService (搜索服务)

**职责**: 调度搜索引擎，处理搜索结果

```python
class SearchService:
    """
    搜索服务
    """
    
    def __init__(self, search_tool, max_results=5):
        self.search_tool = search_tool
        self.max_results = max_results
    
    async def search(self, query: str) -> SearchResult:
        """
        执行搜索
        
        Args:
            query: 搜索查询
            
        Returns:
            搜索结果
        """
        # 1. 执行搜索
        raw_result = await self.search_tool.run({
            "input": query,
            "max_results": self.max_results,
            "mode": "structured"
        })
        
        # 2. 处理结果
        processed = self._process_results(raw_result)
        
        # 3. 去重
        deduped = self._deduplicate(processed)
        
        # 4. 限制 Token 数量
        limited = self._limit_tokens(deduped, max_tokens=4000)
        
        return SearchResult(
            query=query,
            results=limited,
            total=len(raw_result["results"])
        )
    
    def _process_results(self, raw: dict) -> List[dict]:
        """处理原始搜索结果"""
        processed = []
        
        for item in raw["results"]:
            processed.append({
                "title": item.get("title", ""),
                "url": item.get("url", ""),
                "content": item.get("content", "")[:500],  # 限制长度
                "score": item.get("score", 0.0)
            })
        
        return processed
    
    def _deduplicate(self, results: List[dict]) -> List[dict]:
        """去重 (基于 URL)"""
        seen_urls = set()
        deduped = []
        
        for item in results:
            if item["url"] not in seen_urls:
                seen_urls.add(item["url"])
                deduped.append(item)
        
        return deduped
    
    def _limit_tokens(self, results: List[dict], max_tokens: int) -> List[dict]:
        """限制总 Token 数量"""
        limited = []
        total_tokens = 0
        
        for item in results:
            # 估算 Token 数量 (1 token ≈ 4 字符)
            item_tokens = len(item["content"]) // 4
            
            if total_tokens + item_tokens > max_tokens:
                break
            
            limited.append(item)
            total_tokens += item_tokens
        
        return limited
```

#### SummarizationService (总结服务)

**职责**: 调用 Summarizer Agent 总结搜索结果

```python
class SummarizationService:
    """
    总结服务
    """
    
    def __init__(self, summarizer_agent):
        self.summarizer = summarizer_agent
    
    async def summarize(
        self, 
        task: Task, 
        search_result: SearchResult
    ) -> Summary:
        """
        总结搜索结果
        
        Args:
            task: 任务信息
            search_result: 搜索结果
            
        Returns:
            总结内容
        """
        # 1. 格式化搜索结果
        formatted_results = self._format_results(search_result)
        
        # 2. 构建总结 Prompt
        prompt = self._build_prompt(task, formatted_results)
        
        # 3. 调用 Summarizer Agent
        response = await self.summarizer.run(prompt)
        
        # 4. 提取来源引用
        sources = self._extract_sources(response, search_result)
        
        return Summary(
            task_title=task.title,
            content=response,
            sources=sources
        )
    
    def _format_results(self, search_result: SearchResult) -> str:
        """格式化搜索结果为文本"""
        formatted = []
        
        for i, item in enumerate(search_result.results, 1):
            formatted.append(f"""
[{i}] {item['title']}
URL: {item['url']}
内容: {item['content']}
            """)
        
        return "\n".join(formatted)
    
    def _build_prompt(self, task: Task, results: str) -> str:
        """构建总结 Prompt"""
        return f"""
任务: {task.title}
意图: {task.intent}

搜索结果:
{results}

请总结核心发现，使用 Markdown 格式，并为每个观点添加引用 [1], [2] 等。
        """
    
    def _extract_sources(
        self, 
        summary: str, 
        search_result: SearchResult
    ) -> List[str]:
        """提取总结中使用的来源"""
        sources = []
        
        # 查找引用编号 [1], [2], ...
        import re
        citations = re.findall(r'\[(\d+)\]', summary)
        
        for cite in set(citations):
            idx = int(cite) - 1
            if idx < len(search_result.results):
                sources.append(search_result.results[idx]["url"])
        
        return sources
```

#### ReportingService (报告服务)

**职责**: 调用 Reporter Agent 生成最终报告

```python
class ReportingService:
    """
    报告生成服务
    """
    
    def __init__(self, reporter_agent):
        self.reporter = reporter_agent
    
    async def generate_report(
        self,
        topic: str,
        summaries: List[Summary]
    ) -> Report:
        """
        生成最终研究报告
        
        Args:
            topic: 研究主题
            summaries: 所有子任务的总结
            
        Returns:
            研究报告
        """
        # 1. 格式化子任务总结
        formatted_summaries = self._format_summaries(summaries)
        
        # 2. 构建报告 Prompt
        prompt = self._build_prompt(topic, formatted_summaries)
        
        # 3. 调用 Reporter Agent
        response = await self.reporter.run(prompt)
        
        # 4. 整理引用
        references = self._collect_references(summaries)
        
        return Report(
            topic=topic,
            content=response,
            references=references
        )
    
    def _format_summaries(self, summaries: List[Summary]) -> str:
        """格式化子任务总结"""
        formatted = []
        
        for i, summary in enumerate(summaries, 1):
            formatted.append(f"""
## 子任务 {i}: {summary.task_title}

{summary.content}
            """)
        
        return "\n".join(formatted)
    
    def _build_prompt(self, topic: str, summaries: str) -> str:
        """构建报告 Prompt"""
        return f"""
研究主题: {topic}

子任务总结:
{summaries}

请整合以上内容，生成一份完整的研究报告，包括:
1. 标题
2. 概述 (2-3段)
3. 详细分析 (保留所有引用)
4. 总结 (1-2段)
5. 参考文献

使用 Markdown 格式。
        """
    
    def _collect_references(self, summaries: List[Summary]) -> List[str]:
        """收集所有引用来源"""
        all_sources = []
        
        for summary in summaries:
            all_sources.extend(summary.sources)
        
        # 去重并排序
        unique_sources = list(set(all_sources))
        unique_sources.sort()
        
        return unique_sources
```

---

## 🔑 核心知识点总结

### 1. TODO 驱动的研究范式

**本质**: 将开放性问题结构化为可执行任务

**三要素**:
- 智能规划器: 问题分解
- 任务执行器: 信息收集
- 报告生成器: 知识整合

**优势**:
- ⏱️ 效率提升: 1-2小时 → 5-10分钟
- 📊 质量保证: 系统化流程
- 🔍 可追溯: 完整记录

### 2. 三 Agent 协作系统

**Agent 设计原则**:
- 单一职责: 每个 Agent 只做一件事
- 明确接口: 输入输出格式清晰
- 独立可测: 可以单独测试和优化

**协作模式**:
- 顺序协作: Planner → Summarizer → Reporter
- 数据传递: 通过共享状态和文件
- 进度监控: 实时推送执行状态

### 3. 工具系统集成

**SearchTool**: 多引擎搜索
- Tavily: AI优化，质量高
- DuckDuckGo: 免费，无需密钥
- 统一接口，可灵活切换

**NoteTool**: 持久化存储
- 保存子任务总结
- 记录研究进度
- 支持恢复和审计

**ToolRegistry**: 工具管理
- 统一注册和调用
- 自动工具发现
- 便于扩展和维护

### 4. 服务层设计

**分层架构**:
```
Controller (API) → Service (业务逻辑) → Agent (AI能力) → Tool (外部调用)
```

**服务职责**:
- PlanningService: 规划管理
- SearchService: 搜索调度
- SummarizationService: 总结处理
- ReportingService: 报告生成

---

## 📝 学习检查清单

### 理论理解
- [ ] 能解释 TODO 驱动研究范式的核心思想
- [ ] 理解三个 Agent 的职责分工
- [ ] 掌握顺序协作模式的特点
- [ ] 了解 ToolAwareSimpleAgent 的设计目的

### 实践能力
- [ ] 能够配置和运行官方代码
- [ ] 可以修改 Prompt 优化 Agent 行为
- [ ] 能够添加新的搜索引擎
- [ ] 会调试 Agent 协作流程

### 工程素养
- [ ] 理解服务层的分层架构
- [ ] 掌握工具注册和管理机制
- [ ] 了解 SSE 实时推送原理
- [ ] 知道如何优化研究质量

---

## 🎯 下一步学习计划

1. **运行官方代码** (30分钟)
   - 配置环境变量
   - 启动后端和前端
   - 测试完整研究流程

2. **深入代码分析** (1小时)
   - 阅读 agent.py 核心实现
   - 理解服务层的设计
   - 分析 Prompt 设计技巧

3. **功能扩展实践** (2小时)
   - 添加新的搜索引擎
   - 优化总结 Agent 的 Prompt
   - 改进报告格式

4. **文档整理** (30分钟)
   - 完善学习笔记
   - 记录遇到的问题和解决方案
   - 总结学习心得

---

**创建时间**: 2025-12-26  
**最后更新**: 2025-12-26  
**当前状态**: ✅ 理论学习完成，准备实践
