# 第14章 自动化深度研究智能体 - 官方学习指南

> **官方文档**: [第十四章 自动化深度研究智能体](https://github.com/datawhalechina/hello-agents/blob/main/docs/chapter14/第十四章%20自动化深度研究智能体.md)
> 
> **官方代码**: [chapter14/helloagents-deepresearch](https://github.com/datawhalechina/hello-agents/tree/main/code/chapter14)

## 📋 章节概览

本章是 Hello Agents 课程的第二个综合案例，展示了如何构建一个知识密集型的AI应用。与第13章的旅行助手不同，深度研究助手面临的是**信息发散、事实更新、来源追溯**等更复杂的挑战。

**核心价值**：
- ✅ 学习 TODO 驱动的研究范式
- ✅ 掌握顺序协作的 Agent 设计
- ✅ 理解信息检索与知识整合
- ✅ 实现可追溯的研究流程

---

## 🗺️ 学习路线图

### 第一阶段：理解项目背景 (14.1)
📖 **官方文档章节**: 14.1 项目概述与架构设计

**学习目标**：
- [ ] 理解深度研究助手的核心价值
- [ ] 掌握四层架构的设计思路
- [ ] 了解与第13章的差异和联系

**核心知识点**：

1. **为什么需要深度研究助手**
   - 问题：信息过载、缺少结构、重复劳动
   - 价值：节省时间、提高质量、可追溯、可扩展
   - 对比：1-2小时 → 5-10分钟

2. **四层架构设计**
   ```
   前端层 (Vue3 + TypeScript)
      ↕️  SSE 流式通信
   后端层 (FastAPI)
      ↕️  API 调用
   智能体层 (3 个 Agent + 2 个 Tool)
      ↕️  外部 API
   外部服务层 (搜索引擎 + LLM)
   ```

3. **数据流转过程**
   - 用户输入 → SSE 连接 → 状态创建
   - 规划 → 执行 → 报告
   - 流式返回 → 实时展示

**实践建议**：
- 先阅读官方文档理解设计思路
- 对比第13章的并行协作模式
- 思考：为什么选择顺序协作？

**对比学习**：

| 维度 | 第13章 旅行助手 | 第14章 研究助手 |
|------|----------------|----------------|
| **协作模式** | 并行协作 | 顺序协作 |
| **Agent数量** | 4个 | 3个 |
| **核心挑战** | 多数据源整合 | 信息发散控制 |
| **结果形式** | 结构化JSON | Markdown报告 |
| **交互方式** | 一次性返回 | 流式推送 |

---

### 第二阶段：TODO 驱动范式 (14.2)
📖 **官方文档章节**: 14.2 TODO 驱动的研究范式

**学习目标**：
- [ ] 理解 TODO 驱动的核心思想
- [ ] 掌握三阶段研究流程
- [ ] 学习如何设计可执行的子任务

**核心知识点**：

#### 1. 什么是 TODO 驱动

**核心思想**：将"研究"转化为"规划→执行→整合"的结构化流程

**三个核心要素**：
- **智能规划器**：分解研究主题为子任务
- **任务执行器**：对每个任务执行"搜索→总结→记录"
- **报告生成器**：整合所有结果生成报告

#### 2. 三阶段研究流程

**阶段 1：规划 (Planning)**
```
输入：研究主题 + 当前日期
处理：分解为 3-5 个子任务
输出：JSON 格式的任务列表

任务包含：
- title: 子任务标题
- intent: 研究意图
- query: 搜索查询（英文）
```

**阶段 2：执行 (Execution)**
```
对每个子任务循环：
  1. 使用 SearchTool 搜索信息
  2. 调用 Summarizer Agent 总结
  3. 使用 NoteTool 记录结果
  4. 推送进度到前端
```

**阶段 3：报告 (Reporting)**
```
输入：所有子任务的总结
处理：整合、润色、添加结构
输出：Markdown 格式的研究报告

报告结构：
1. 标题
2. 概述 (2-3段)
3. 详细分析 (每个子任务)
4. 总结 (1-2段)
5. 参考文献
```

**实践任务**：
```python
# 尝试理解这个流程的设计
# 思考问题：
# 1. 为什么要分三个阶段？
# 2. 为什么搜索查询要用英文？
# 3. 如何保证子任务之间的逻辑关系？
# 4. 如何控制研究的深度和广度？
```

**设计亮点**：
- ✨ **渐进式推进**：每完成一个任务就有成果
- ✨ **可中断恢复**：保存中间结果，支持恢复
- ✨ **质量可控**：每个阶段都可以独立优化
- ✨ **用户可见**：实时展示进度和结果

---

### 第三阶段：智能体系统 (14.3)
📖 **官方文档章节**: 14.3 智能体系统设计

**学习目标**：
- [ ] 理解三个 Agent 的职责划分
- [ ] 掌握 ToolAwareSimpleAgent 的设计
- [ ] 学习顺序协作模式的实现

**核心知识点**：

#### 1. 三个专门 Agent

| Agent | 角色定位 | 核心能力 | 输入 | 输出 |
|-------|---------|---------|------|------|
| **TODO Planner** | 研究规划专家 | 问题分解 | 主题+日期 | 子任务列表(JSON) |
| **Task Summarizer** | 任务总结专家 | 信息提取 | 任务+搜索结果 | 总结(Markdown) |
| **Report Writer** | 报告撰写专家 | 知识整合 | 所有总结 | 报告(Markdown) |

#### 2. Agent 设计要点

**Planner Agent 的 Prompt 设计**：
```python
关键要素：
1. 明确角色和目标
2. 提供当前日期（获取最新信息）
3. 强调输出格式（JSON）
4. 给出具体示例
5. 设定约束（3-5个任务）

示例 Prompt：
"""
你是研究规划专家。请将以下主题分解为 3-5 个子任务。

主题: {topic}
日期: {today}

输出格式（JSON）:
{
  "todos": [
    {
      "title": "子任务标题",
      "intent": "研究意图",
      "query": "英文搜索查询"
    }
  ]
}

要求：
- 任务之间有逻辑关系（从基础到深入）
- 查询使用英文（搜索效果更好）
- 覆盖主题的不同方面
"""
```

**Summarizer Agent 的 Prompt 设计**：
```python
关键要素：
1. 强调信息提取（不编造）
2. 要求添加来源引用
3. 使用 Markdown 格式
4. 保留关键数据

示例 Prompt：
"""
你是任务总结专家。请总结以下搜索结果的核心发现。

任务: {task_title}
意图: {task_intent}

搜索结果:
{search_results}

要求：
- 提取 3-5 个核心观点
- 每个观点添加来源引用 [1], [2]
- 保留关键数据（数字、日期）
- 使用 Markdown 格式
"""
```

**Reporter Agent 的 Prompt 设计**：
```python
关键要素：
1. 整合所有子任务总结
2. 生成结构化报告
3. 保留所有引用
4. 语言专业但易懂

示例 Prompt：
"""
你是报告撰写专家。请整合以下内容生成研究报告。

主题: {topic}

子任务总结:
{summaries}

报告结构：
1. 标题
2. 概述 (2-3段)
3. 详细分析（保留所有引用）
4. 总结 (1-2段)
5. 参考文献

要求：
- 语言专业但通俗
- 逻辑清晰连贯
- 保留所有 [1], [2] 引用
- 使用 Markdown 格式
"""
```

#### 3. ToolAwareSimpleAgent

**为什么需要**：
- 普通 SimpleAgent 无法监听工具调用
- 需要实时推送进度到前端
- 需要记录工具调用历史用于调试

**实现原理**：
```python
class ToolAwareSimpleAgent(SimpleAgent):
    """扩展 SimpleAgent，增加工具调用监听"""
    
    def __init__(self, ..., tool_call_listener=None):
        super().__init__(...)
        self._tool_call_listener = tool_call_listener
    
    def _execute_tool_call(self, tool_name, parameters):
        # 1. 执行原始工具调用
        result = super()._execute_tool_call(tool_name, parameters)
        
        # 2. 触发监听器
        if self._tool_call_listener:
            self._tool_call_listener({
                "agent_name": self.name,
                "tool_name": tool_name,
                "parameters": parameters,
                "result": result
            })
        
        # 3. 返回结果
        return result
```

**应用场景**：
- 📊 实时进度推送
- 📝 日志记录
- 📈 性能监控
- 🐛 调试诊断

#### 4. 顺序协作模式

**流程图**：
```
DeepResearchAgent (协调器)
    ↓
1. Planner Agent
    → 生成 3-5 个子任务
    ↓
2. 循环执行每个子任务
    ├→ SearchTool: 搜索信息
    ├→ Summarizer Agent: 总结
    ├→ NoteTool: 保存结果
    └→ 推送进度
    ↓
3. Reporter Agent
    → 整合所有总结
    → 生成最终报告
```

**特点对比**：

| 特点 | 并行协作 | 顺序协作 |
|------|---------|---------|
| **执行方式** | 多个 Agent 同时工作 | 按顺序逐个执行 |
| **适用场景** | 任务独立、可并行 | 任务有依赖关系 |
| **性能** | 快（并发） | 慢（串行） |
| **可控性** | 难以控制顺序 | 易于控制流程 |
| **调试** | 难（并发问题） | 易（单线程） |
| **成本** | 高（多个LLM调用） | 中（顺序调用） |

**实践建议**：
- 阅读官方代码的 `agent.py`
- 理解 DeepResearchAgent 如何协调三个 Agent
- 尝试修改 Prompt 优化结果质量
- 思考：如何添加第四个 Agent？

---

### 第四阶段：工具系统 (14.4)
📖 **官方文档章节**: 14.4 工具系统集成

**学习目标**：
- [ ] 掌握 SearchTool 的多引擎支持
- [ ] 理解 NoteTool 的持久化机制
- [ ] 学习 ToolRegistry 的管理模式

**核心知识点**：

#### 1. SearchTool 多引擎支持

**支持的搜索引擎**：

| 引擎 | 特点 | 优势 | 劣势 | 成本 | API密钥 |
|------|------|------|------|------|---------|
| **Tavily** | AI优化 | 质量高、去重好、专为AI设计 | 需要付费 | $$ | 需要 |
| **DuckDuckGo** | 隐私保护 | 免费、无需密钥 | 结果一般 | 免费 | 不需要 |
| **Perplexity** | AI生成 | 直接给答案 | 需要付费 | $$$ | 需要 |
| **SearXNG** | 自托管 | 隐私、可控 | 需自己搭建 | 免费 | 不需要 |

**统一调用接口**：
```python
from helloagents.tools import SearchTool

# 初始化（选择引擎）
search_tool = SearchTool(
    name="web_search",
    description="搜索互联网信息",
    backend="tavily",  # 或 duckduckgo, perplexity, searxng
    api_key="your-api-key"  # Tavily/Perplexity 需要
)

# 使用搜索
result = search_tool.run({
    "input": "量子计算 2025",
    "max_results": 5,
    "mode": "structured"
})
```

**配置方法**：
```bash
# .env 文件
SEARCH_API=tavily                    # 选择引擎
TAVILY_API_KEY=tvly-xxxxx           # Tavily 密钥
PERPLEXITY_API_KEY=pplx-xxxxx       # Perplexity 密钥
SEARXNG_URL=http://localhost:8888   # SearXNG 地址
```

**选择建议**：
- 🆓 **初学者**：DuckDuckGo（免费、无需配置）
- 💎 **追求质量**：Tavily（专为AI优化）
- 🔒 **重视隐私**：SearXNG（自托管）
- 🤖 **需要答案**：Perplexity（AI生成）

#### 2. NoteTool 持久化机制

**作用**：保存研究进度和结果

**文件组织**：
```
workspace/
└── research_001/              # 单次研究
    ├── notes/                 # 子任务笔记
    │   ├── task_1.md
    │   ├── task_2.md
    │   └── task_3.md
    ├── reports/               # 最终报告
    │   └── final_report.md
    └── meta.json             # 元数据
```

**API 使用**：
```python
from helloagents.tools import NoteTool

# 初始化
note_tool = NoteTool(
    name="research_notes",
    description="保存研究笔记",
    workspace="./workspace/research_001"
)

# 保存笔记
note_tool.run({
    "action": "save",
    "filename": "task_1.md",
    "content": "## 总结内容..."
})

# 读取笔记
note = note_tool.run({
    "action": "read",
    "filename": "task_1.md"
})

# 列出所有笔记
notes = note_tool.run({
    "action": "list"
})
```

**应用场景**：
- ✅ 进度恢复：研究中断后可以恢复
- ✅ 审计追溯：查看完整研究过程
- ✅ 结果复用：保存的笔记可用于后续研究
- ✅ 调试分析：检查每个阶段的输出

#### 3. ToolRegistry 工具管理

**作用**：统一管理所有工具的注册和调用

**使用方法**：
```python
from helloagents import ToolRegistry

# 创建注册表
registry = ToolRegistry()

# 注册工具
registry.register_tool(search_tool)
registry.register_tool(note_tool)

# 创建 Agent（自动使用已注册的工具）
agent = ToolAwareSimpleAgent(
    name="研究助手",
    llm=llm,
    tool_registry=registry
)
```

**工具发现机制**：
1. Registry 维护工具列表和描述
2. Agent 从 Registry 获取工具描述
3. LLM 根据描述选择合适的工具
4. Agent 通过 Registry 执行工具调用

**优势**：
- 🔧 **解耦**：Agent 不依赖具体工具实现
- 🔌 **插拔**：可随时添加/移除工具
- 🔄 **复用**：多个 Agent 共享工具
- 🐛 **调试**：统一监控所有工具调用

---

### 第五阶段：服务层实现 (14.5)
📖 **官方文档章节**: 14.5 服务层实现

**学习目标**：
- [ ] 理解服务层的分层架构
- [ ] 掌握四个核心服务的职责
- [ ] 学习如何连接 Agent 和工具

**核心知识点**：

#### 1. 服务层架构

**分层设计**：
```
Controller (API层)
    ↓ 调用
Service (业务逻辑层)
    ↓ 调用
Agent (AI能力层)
    ↓ 调用
Tool (外部服务层)
```

**服务列表**：
```
services/
├── planner.py           # 规划服务
├── search.py            # 搜索服务
├── summarizer.py        # 总结服务
├── reporter.py          # 报告服务
├── notes.py             # 笔记服务
├── tool_events.py       # 工具事件监听
└── text_processing.py   # 文本处理
```

#### 2. 四个核心服务

**PlanningService - 规划服务**
```python
职责：
- 构建规划 Prompt
- 调用 Planner Agent
- 解析 JSON 响应
- 验证任务格式

关键方法：
- create_plan(topic) → List[Task]
- _build_prompt(topic) → str
- _parse_response(response) → List[dict]
- _validate_tasks(tasks) → List[Task]
```

**SearchService - 搜索服务**
```python
职责：
- 调度搜索引擎
- 执行搜索
- 处理结果（去重、限制Token）
- 错误处理和缓存

关键方法：
- search(query) → SearchResult
- _process_results(raw) → List[dict]
- _deduplicate(results) → List[dict]
- _limit_tokens(results, max) → List[dict]
```

**SummarizationService - 总结服务**
```python
职责：
- 格式化搜索结果
- 构建总结 Prompt
- 调用 Summarizer Agent
- 提取来源引用

关键方法：
- summarize(task, search_result) → Summary
- _format_results(search_result) → str
- _build_prompt(task, results) → str
- _extract_sources(summary, result) → List[str]
```

**ReportingService - 报告服务**
```python
职责：
- 格式化子任务总结
- 构建报告 Prompt
- 调用 Reporter Agent
- 整理引用

关键方法：
- generate_report(topic, summaries) → Report
- _format_summaries(summaries) → str
- _build_prompt(topic, summaries) → str
- _collect_references(summaries) → List[str]
```

#### 3. 服务层设计模式

**依赖注入**：
```python
class PlanningService:
    def __init__(self, planner_agent):
        self.planner = planner_agent  # 注入依赖
```

**单一职责**：
- 每个服务只负责一件事
- 便于测试和维护

**接口统一**：
- 所有服务都有清晰的输入输出
- 便于组合和复用

**实践建议**：
- 阅读 `services/` 目录下的代码
- 理解每个服务的职责边界
- 思考：如何添加新的服务？

---

### 第六阶段：前端交互 (14.6)
📖 **官方文档章节**: 14.6 前端交互设计

**学习目标**：
- [ ] 理解全屏模态对话框 UI
- [ ] 掌握 SSE 实时推送机制
- [ ] 学习 Markdown 结果可视化

**核心知识点**：

#### 1. 全屏模态对话框 UI

**UI 组件结构**：
```
ResearchModal (全屏模态框)
├── Header (顶部栏)
│   ├── 研究主题
│   └── 关闭按钮
├── ProgressBar (进度区域)
│   ├── 当前阶段
│   └── 进度百分比
├── ContentArea (内容区域)
│   ├── MarkdownViewer (结果展示)
│   └── LoadingSpinner (加载动画)
└── Footer (底部栏)
    └── 状态信息
```

**响应式设计**：
- 桌面端：全屏显示
- 平板端：80% 宽度
- 移动端：全屏显示

#### 2. SSE 实时推送

**什么是 SSE**：
- Server-Sent Events（服务器推送事件）
- 单向通信：服务器 → 客户端
- 基于 HTTP，比 WebSocket 简单
- 适合实时进度推送

**后端实现**：
```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse

@app.get("/api/research")
async def research_stream(topic: str):
    async def event_generator():
        # 发送进度事件
        yield f"data: {json.dumps({'type': 'progress', 'stage': 'planning'})}\n\n"
        
        # 规划阶段
        todos = await planner.plan(topic)
        yield f"data: {json.dumps({'type': 'plan', 'todos': todos})}\n\n"
        
        # 执行阶段
        for i, todo in enumerate(todos):
            result = await execute_task(todo)
            yield f"data: {json.dumps({'type': 'task_result', 'index': i, 'result': result})}\n\n"
        
        # 报告阶段
        report = await generate_report(todos)
        yield f"data: {json.dumps({'type': 'report', 'content': report})}\n\n"
        
        # 完成
        yield f"data: {json.dumps({'type': 'done'})}\n\n"
    
    return StreamingResponse(event_generator(), media_type="text/event-stream")
```

**前端实现**：
```typescript
// 创建 SSE 连接
const eventSource = new EventSource(`/api/research?topic=${encodeURIComponent(topic)}`)

// 监听消息
eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data)
    
    switch (data.type) {
        case 'progress':
            updateProgress(data.stage)
            break
        case 'plan':
            displayPlan(data.todos)
            break
        case 'task_result':
            appendResult(data.index, data.result)
            break
        case 'report':
            displayReport(data.content)
            break
        case 'done':
            eventSource.close()
            break
    }
}

// 错误处理
eventSource.onerror = (error) => {
    console.error('SSE error:', error)
    eventSource.close()
}
```

#### 3. Markdown 可视化

**使用 marked 库渲染**：
```typescript
import { marked } from 'marked'

// 渲染 Markdown
const html = marked.parse(markdownContent)

// 显示到页面
contentDiv.innerHTML = html
```

**自定义样式**：
```css
/* Markdown 内容样式 */
.markdown-content {
    /* 标题 */
    h1, h2, h3 { color: #333; }
    
    /* 段落 */
    p { line-height: 1.6; }
    
    /* 列表 */
    ul, ol { padding-left: 2em; }
    
    /* 引用 */
    blockquote { 
        border-left: 4px solid #ddd;
        padding-left: 1em;
    }
    
    /* 代码 */
    code { 
        background: #f5f5f5;
        padding: 2px 4px;
    }
    
    /* 链接 */
    a { color: #0066cc; }
}
```

**特殊处理来源引用**：
```typescript
// 将 [1], [2] 转换为可点击的链接
function processReferences(html: string, sources: string[]) {
    return html.replace(/\[(\d+)\]/g, (match, num) => {
        const index = parseInt(num) - 1
        if (index < sources.length) {
            return `<a href="${sources[index]}" target="_blank" class="reference">[${num}]</a>`
        }
        return match
    })
}
```

---

## 🛠️ 实践项目建议

### 初级：运行官方代码

**目标**：成功运行完整的研究流程

**步骤**：
1. 克隆代码库
2. 配置环境变量
3. 启动后端和前端
4. 测试研究功能

**预期时间**：30分钟

### 中级：功能优化

**目标**：改进现有功能

**建议方向**：
1. 优化 Prompt 提高结果质量
2. 添加新的搜索引擎（如 Google Custom Search）
3. 改进报告格式和样式
4. 添加研究历史记录功能

**预期时间**：2-3小时

### 高级：架构扩展

**目标**：添加新功能或改进架构

**建议方向**：
1. 添加第四个 Agent（如数据分析 Agent）
2. 实现多轮深入研究（用户可以对结果提问）
3. 集成向量数据库支持语义搜索
4. 添加导出功能（PDF、Word）
5. 实现协作研究（多用户共享）

**预期时间**：1-2天

---

## 📚 相关资源

### 官方资源
- [第14章官方文档](https://github.com/datawhalechina/hello-agents/blob/main/docs/chapter14/第十四章%20自动化深度研究智能体.md)
- [第14章完整代码](https://github.com/datawhalechina/hello-agents/tree/main/code/chapter14)
- [HelloAgents 框架文档](https://github.com/datawhalechina/hello-agents)

### 技术文档
- [FastAPI 官方文档](https://fastapi.tiangolo.com/)
- [Vue 3 官方文档](https://vuejs.org/)
- [SSE 规范](https://html.spec.whatwg.org/multipage/server-sent-events.html)
- [Tavily API 文档](https://docs.tavily.com/)

### 前置知识复习
- Task01-02: Agent 基础和范式
- Task03: RAG 系统（本章的信息检索）
- Task04: 上下文管理（本章的 Token 控制）
- Task05: MCP 协议（本章的工具集成）

---

## ✅ 学习检查清单

### 理论理解
- [ ] 能解释 TODO 驱动研究范式的核心思想
- [ ] 理解三个 Agent 的职责分工和协作流程
- [ ] 掌握顺序协作模式的特点和优势
- [ ] 了解 ToolAwareSimpleAgent 的设计目的
- [ ] 理解服务层的分层架构

### 技术掌握
- [ ] 能够配置不同的搜索引擎
- [ ] 掌握 SSE 的实现和使用
- [ ] 了解 Markdown 渲染的方法
- [ ] 会使用 NoteTool 持久化结果
- [ ] 理解 ToolRegistry 的工作原理

### 实践能力
- [ ] 能够运行官方代码
- [ ] 可以修改 Prompt 优化结果
- [ ] 能够添加新的搜索引擎
- [ ] 会调试 Agent 协作流程
- [ ] 能够扩展新的功能

### 工程素养
- [ ] 理解分层架构的设计原则
- [ ] 掌握依赖注入的使用
- [ ] 了解单一职责原则
- [ ] 知道如何进行错误处理
- [ ] 会编写可维护的代码

---

## 💡 学习建议

### 1. 对比学习
将第14章与第13章对比学习：
- 协作模式：并行 vs 顺序
- 应用场景：确定性任务 vs 开放性研究
- 结果形式：结构化数据 vs 长文本报告

### 2. 渐进式学习
按以下顺序逐步深入：
- Week 1: 理解架构和流程
- Week 2: 研究 Agent 设计
- Week 3: 学习工具系统
- Week 4: 实践功能扩展

### 3. 动手实践
每学完一个阶段就动手尝试：
- 理论 → 代码阅读 → 修改实验 → 总结反思

### 4. 扩展思考
思考如何将这个架构应用到其他场景：
- 📚 教育：自动生成学习资料
- 💼 商业：市场调研和竞品分析
- 🏥 医疗：疾病知识库构建
- 📰 新闻：热点事件追踪

### 5. 注意事项
- ⚠️ **API 成本**：注意搜索 API 的调用成本
- ⚠️ **Token 限制**：控制每次搜索的结果数量
- ⚠️ **错误处理**：网络请求可能失败，需要重试机制
- ⚠️ **质量控制**：LLM 可能生成错误信息，需要验证

---

## 🎯 下一步

完成第14章后，建议：

1. **总结对比**：对比第13章和第14章的异同
2. **知识整合**：将两章的技术整合到一个项目中
3. **准备第15章**：开始学习赛博小镇（Agent与游戏结合）

**继续前进**：现在就打开[官方文档](https://github.com/datawhalechina/hello-agents/blob/main/docs/chapter14/第十四章%20自动化深度研究智能体.md)，开始你的深度研究助手之旅！ 🚀

---

**创建时间**: 2025-12-26  
**最后更新**: 2025-12-26  
**适用对象**: 已完成第13章学习的开发者
